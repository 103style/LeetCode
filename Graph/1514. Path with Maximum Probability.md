# [1514. Path with Maximum Probability](https://leetcode.com/problems/path-with-maximum-probability/)
---

**the third one in Weekly Contest 197.**

---

**Difficulty** : **Medium**

**Related Topics** : **Graph**

---

You are given an undirected weighted graph of n nodes (0-indexed), represented by an edge list where `edges[i] = [a, b]` is an undirected edge connecting the nodes a and b with a probability of success of traversing that edge `succProb[i]`.

Given two nodes `start` and `end`, find the path with the maximum probability of success to go from `start` to `end` and return its success probability.

If there is no path from `start` to `end`, **return 0**. Your answer will be accepted if it differs from the correct answer by at most **1e-5**.



### Example 1:
![1](https://assets.leetcode.com/uploads/2019/09/20/1558_ex1.png)
```
Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2
Output: 0.25000
Explanation: There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25.
```

### Example 2:
![2](https://assets.leetcode.com/uploads/2019/09/20/1558_ex2.png)
```
Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2
Output: 0.30000
```

### Example 3:
![3](https://assets.leetcode.com/uploads/2019/09/20/1558_ex3.png)
```
Input: n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2
Output: 0.00000
Explanation: There is no path between 0 and 2.
```

### Constraints:
* `2 <= n <= 10^4`
* `0 <= start, end < n`
* `start != end`
* `0 <= a, b < n`
* `a != b`
* `0 <= succProb.length == edges.length <= 2*10^4`
* `0 <= succProb[i] <= 1`
* There is at most one edge between every two nodes.

---

### Solution
* **mine**
  * **Java**
    * ``
      ```
      ```


---


* **the most votes**
  * **edges.length** `Runtime: 10 ms, faster than 100%, Memory Usage: 50.1 MB, less than 100.00% of Java online submissions`
    ```
    // O(N * L)time  L = edges.length
    // O(N)space
    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {
        double[] dp = new double[n];
        dp[start] = 1;
        while (true) {
            boolean k = false;
            for (int j = 0; j < edges.length; j++) {
                if (dp[edges[j][0]] * succProb[j] > dp[edges[j][1]]) {
                    dp[edges[j][1]] = dp[edges[j][0]] * succProb[j];
                    k = true;
                }
                if (dp[edges[j][1]] * succProb[j] > dp[edges[j][0]]) {
                    dp[edges[j][0]] = dp[edges[j][1]] * succProb[j];
                    k = true;
                }
            }
            if (!k) break;
        }
        return dp[end];
    }
    ```
  
  * **BFS** `Runtime: 49 ms, faster than 92.82%, Memory Usage: 51.7 MB, less than 100.00% of Java online submissions`
    ```
    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {
        if (n == 0) {
            return 0;
        }
        List<List<int[]>> G = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            G.add(new ArrayList<>());
        }
        for (int i = 0; i < edges.length; i++) {
            int[] edge = edges[i];
            G.get(edge[0]).add(new int[]{i, edge[1]});
            G.get(edge[1]).add(new int[]{i, edge[0]});
        }

        double[] probs = new double[n];
        LinkedList<Integer> Q = new LinkedList<>();
        probs[start] = 1;
        Q.addLast(start);

        while (!Q.isEmpty()) {
            int qsize = Q.size();
            Set<Integer> set = new HashSet<>();

            for (int i = 0; i < qsize; i++) {
                int v = Q.poll();
                if (v == end) {
                    continue;
                }
                for (int[] ew : G.get(v)) {
                    double nextProb = probs[v] * succProb[ew[0]];
                    if (nextProb > probs[ew[1]]) {
                        probs[ew[1]] = nextProb;
                        set.add(ew[1]);
                    }
                }
            }
            for (int w : set) {
                Q.addLast(w);
            }
        }
        return probs[end];
    }
    ```

---
