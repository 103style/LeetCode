# [130. Surrounded Regions](https://leetcode.com/problems/surrounded-regions/)

---

**leetcode Daily Challenge on June 17, 2020**

---

> Given a 2D board containing `'X'` and `'O'` (**the letter O**), capture all regions surrounded by `'X'`.
>
> A region is captured by flipping all `'O'`s into `'X'`s in that surrounded region.
>
> ### Example:
> ```
> X X X X
> X O O X
> X X O X
> X O X X
> ```
>
> After running your function, the board should be:
> ```
> X X X X
> X X X X
> X X X X
> X O X X
> ```
>
> **Explanation**:
>
> Surrounded regions shouldn’t be on the border, which means that any `'O'` on the border of the board are not flipped to `'X'`. Any `'O'` that is not on the border and it is not connected to an `'O'` on the border will be flipped to `'X'`. Two cells are connected if they are adjacent cells connected horizontally or vertically.


---

### Solution
* **mine**
  * **Java**
    * **DFS** `Runtime: 1 ms, faster than 99.81%, Memory Usage: 41.6 MB, less than 62.14% of Java online submissions`
      ```
      // O(S)time O(D)space
      // S is r + c + count(O) after solve
      // D is the max depth of connected O from border
      public char REPLACE = '*';
      public void solve(char[][] board) {
          if (board == null || board.length < 3 || board[0].length < 3) {
              return;
          }
          int r = board.length;
          int c = board[0].length;
          for (int i = 0; i < r; i++) {
              if (board[i][0] == 'O') {
                  dfs(board, i, 0);
              }
              if (board[i][c - 1] == 'O') {
                  dfs(board, i, c - 1);
              }
          }
          for (int i = 0; i < c; i++) {
              if (board[0][i] == 'O') {
                  dfs(board, 0, i);
              }
              if (board[r - 1][i] == 'O') {
                  dfs(board, r - 1, i);
              }
          }
          for (int i = 0; i < r; i++) {
              for (int j = 0; j < c; j++) {
                  if (board[i][j] == REPLACE) {
                      board[i][j] = 'O';
                  }else{
                      board[i][j] = 'X';
                  }
              }
          }
      }

      void dfs(char[][] board, int x, int y) {
          if (x < 0 || y < 0 || x >= board.length || y >= board[0].length) {
              return;
          }
          if (board[x][y] == REPLACE) {
              return;
          }
          if (board[x][y] != 'O') {
              return;
          }
          board[x][y] = REPLACE;
          dfs(board, x - 1, y);
          dfs(board, x, y - 1);
          dfs(board, x + 1, y);
          dfs(board, x, y + 1);
      }
      ```

---

* **the other solution**
  * **BFS** `Runtime: 2 ms, faster than 59.06%, Memory Usage: 41.3 MB, less than 83.42% of Java online submissions`
    ```
    public void solve(char[][] board) {
        if (board == null || board.length == 0) return;
        int m = board.length;
        int n = board[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 从边缘第一个是o的开始搜索
                boolean isEdge = i == 0 || j == 0 || i == m - 1 || j == n - 1;
                if (isEdge && board[i][j] == 'O') {
                    bfs(board, i, j);
                }
            }
        }

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == 'O') {
                    board[i][j] = 'X';
                }
                if (board[i][j] == '#') {
                    board[i][j] = 'O';
                }
            }
        }
    }
    
    public void bfs(char[][] board, int i, int j) {
        Queue<Pos> queue = new LinkedList<>();
        queue.add(new Pos(i, j));
        board[i][j] = '#';
        while (!queue.isEmpty()) {
            Pos current = queue.poll();
            // 上
            if (current.i - 1 >= 0
                    && board[current.i - 1][current.j] == 'O') {
                queue.add(new Pos(current.i - 1, current.j));
                board[current.i - 1][current.j] = '#';
                // 没有continue.
            }
            // 下
            if (current.i + 1 <= board.length - 1
                    && board[current.i + 1][current.j] == 'O') {
                queue.add(new Pos(current.i + 1, current.j));
                board[current.i + 1][current.j] = '#';
            }
            // 左
            if (current.j - 1 >= 0
                    && board[current.i][current.j - 1] == 'O') {
                queue.add(new Pos(current.i, current.j - 1));
                board[current.i][current.j - 1] = '#';
            }
            // 右
            if (current.j + 1 <= board[0].length - 1
                    && board[current.i][current.j + 1] == 'O') {
                queue.add(new Pos(current.i, current.j + 1));
                board[current.i][current.j + 1] = '#';
            }
        }
    }

    public class Pos {
        int i;
        int j;

        Pos(int i, int j) {
            this.i = i;
            this.j = j;
        }
    }
    ```
  
  * **Union Find** `Runtime: 4 ms, faster than 24.10%, Memory Usage: 41.1 MB, less than 94.79% of Java online submissions`
    ```
    int[] unionSet; // union find set
    boolean[] hasEdgeO; // whether an union has an 'O' which is on the edge of the matrix
    public void solve(char[][] board) {
        if (board.length == 0 || board[0].length == 0) return;

        // init, every char itself is an union
        int height = board.length, width = board[0].length;
        unionSet = new int[height * width];
        hasEdgeO = new boolean[unionSet.length];
        for (int i = 0; i < unionSet.length; i++) unionSet[i] = i;
        for (int i = 0; i < hasEdgeO.length; i++) {
            int x = i / width, y = i % width;
            hasEdgeO[i] = (board[x][y] == 'O' && (x == 0 || x == height - 1 || y == 0 || y == width - 1));
        }

        // iterate the matrix, for each char, union it + its upper char + its right char if they equals to each other
        for (int i = 0; i < unionSet.length; i++) {
            int x = i / width, y = i % width, up = x - 1, right = y + 1;
            if (up >= 0 && board[x][y] == board[up][y]) union(i, i - width);
            if (right < width && board[x][y] == board[x][right]) union(i, i + 1);
        }

        // for each char in the matrix, if it is an 'O' and its union doesn't has an 'edge O', the whole union should be setted as 'X'
        for (int i = 0; i < unionSet.length; i++) {
            int x = i / width, y = i % width;
            if (board[x][y] == 'O' && !hasEdgeO[findSet(i)])
                board[x][y] = 'X';
        }
    }

    private void union(int x, int y) {
        int rootX = findSet(x);
        int rootY = findSet(y);
        // if there is an union has an 'edge O',the union after merge should be marked too
        boolean hasEdgeO = this.hasEdgeO[rootX] || this.hasEdgeO[rootY];
        unionSet[rootX] = rootY;
        this.hasEdgeO[rootY] = hasEdgeO;
    }

    private int findSet(int x) {
        if (unionSet[x] == x) return x;
        unionSet[x] = findSet(unionSet[x]);
        return unionSet[x];
    }
    ```
