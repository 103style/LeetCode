# [1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)
---

> **Difficulty** : **Medium**
> 
> **Related Topics** : **Array**、**Binary Search**

---

> Given an integer array `bloomDay`, an integer `m` and an integer `k`.
>
> We need to make `m` bouquets. To make a bouquet, you need to use `k` **adjacent flowers** from the garden.
>
> The garden consists of `n` flowers, the `ith` flower will bloom in the `bloomDay[i]` and then can be used in **exactly one** bouquet.
>
> Return the minimum number of days you need to wait to be able to make `m` bouquets from the garden. If it is impossible to make `m` bouquets return **-1**.
>
>
>
> ### Example 1:
> ```
> Input: bloomDay = [1,10,3,10,2], m = 3, k = 1
> Output: 3
> Explanation: Let's see what happened in the first three days. x means flower bloomed and _ means flower didn't bloom in the garden.
> We need 3 bouquets each should contain 1 flower.
> After day 1: [x, _, _, _, _]   // we can only make one bouquet.
> After day 2: [x, _, _, _, x]   // we can only make two bouquets.
> After day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.
> ```
>
> ### Example 2:
> ```
> Input: bloomDay = [1,10,3,10,2], m = 3, k = 2
> Output: -1
> Explanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.
> ```
>
> ### Example 3:
> ```
> Input: bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3
> Output: 12
> Explanation: We need 2 bouquets each should have 3 flowers.
> Here's the garden after the 7 and 12 days:
> After day 7: [x, x, x, x, _, x, x]
> We can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.
> After day 12: [x, x, x, x, x, x, x]
> It is obvious that we can make two bouquets in different ways.
> ```
>
> ### Example 4:
> ```
> Input: bloomDay = [1000000000,1000000000], m = 1, k = 1
> Output: 1000000000
> Explanation: You need to wait 1000000000 days to have a flower ready for a bouquet.
> ```
>
> ### Example 5:
> ```
> Input: bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2
> Output: 9
> ```
>
> ### Constraints:
> * `bloomDay.length == n`
> * `1 <= n <= 10^5`
> * `1 <= bloomDay[i] <= 10^9`
> * `1 <= m <= 10^6`
> * `1 <= k <= n`

---


### Solution
* **mine**
  * **Java**
    * **Binary Search** `got from the disscuss`
      ```
      // O(N * logM)time  M = max
      // O(1)space
      public int minDays(int[] bloomDay, int m, int k) {
          int max = 1_000_000_001;
          int l = 0, e = max;
          while(l < e){
              int mid = (l + e) >> 1;
              if(check(bloomDay, mid, k) >= m){
                  e = mid;
              }else{
                  l =  mid + 1;
              }
          }
          return l == max ? -1 : l;
      }

      int check(int[] bloomDay, int day, int k){
          int count = 0;
          int t = 0;
          for(int d : bloomDay){
              if(d > day){
                  t = 0;
              }else{
                  t++;
              }
              if(t == k){
                  count++;
                  t = 0;
              }
          }
          return count;
      }
      ```
  
---


* **the most votes**
  * **Binary Search**
  
    `Runtime: 24 ms, faster than 78.74%, Memory Usage: 48.2 MB, less than 100.00% of Java online submissions`
    ```
    // O(N * log(M))time  O(1)space
    // M is the largest one in A
    public int minDays(int[] A, int m, int k) {
        int n = A.length, left = 1, right = (int)1e9;
        if (m * k > n) return -1;
        while (left < right) {
            int mid = (left + right) / 2, flow = 0, bouq = 0;
            for (int j = 0; j < n; ++j) {
                if (A[j] > mid) {
                    flow = 0;
                } else if (++flow >= k) {
                    bouq++;
                    flow = 0;
                }
            }
            if (bouq < m) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
    ```


----
