# [109. Convert Sorted List to Binary Search Tree](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/)

Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

### Example:
```
Given the sorted linked list: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5
```

### Solution
* **Java**
  * **mine**
  
    `Runtime: 0 ms, faster than 100.00%, Memory Usage: 40.6 MB, less than 18.42% of Java online submissions`
    ```
    public TreeNode sortedListToBST(ListNode head) {
        if (head == null) {
            return null;
        }
        if (head.next == null) {
            return new TreeNode(head.val);
        }
        if (head.next.next == null) {
            return new TreeNode(head.next.val, new TreeNode(head.val), null);
        }
        ListNode node  = new ListNode(0,head);
        ListNode slow = head;
        ListNode fast = head;
        //get the middle node
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            node = node.next;
        }
        //left part is treenode's left
        //right part is treenode's right
        TreeNode res = new TreeNode(slow.val);
        res.right = sortedListToBST(slow.next);
        node.next = null;
        res.left = sortedListToBST(head);
        return res;
    }
    ```
    
  * **the most votes**
  
    `Runtime: 0 ms, faster than 100.00%, Memory Usage: 41.5 MB, less than 5.26% of Java online submissions`
    ```
    public TreeNode sortedListToBST(ListNode head) {
        if(head==null) return null;
        return toBST(head,null);
    }
    public TreeNode toBST(ListNode head, ListNode tail){
        ListNode slow = head;
        ListNode fast = head;
        if(head==tail) return null;

        while(fast!=tail&&fast.next!=tail){
            fast = fast.next.next;
            slow = slow.next;
        }
        TreeNode thead = new TreeNode(slow.val);
        thead.left = toBST(head,slow);
        thead.right = toBST(slow.next,tail);
        return thead;
    }
    ```
