# [769. Max Chunks To Make Sorted](https://leetcode.com/problems/max-chunks-to-make-sorted/description/)
---

> **Difficulty** : **Medium**
>
> **Related Topics** : **Array**

---

> Given an `array` arr that is a permutation of `[0, 1, ..., arr.length - 1]`, we split the array into some number of "chunks" (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array.
>
> What is the most number of chunks we could have made?
>
> ### Example 1:
> ```
> Input: arr = [4,3,2,1,0]
> Output: 1
> Explanation:
> Splitting into two or more chunks will not return the required result.
> For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn't sorted.
> ```
>
> ### Example 2:
> ```
> Input: arr = [1,0,2,3,4]
> Output: 4
> Explanation:
> We can split into two chunks, such as [1, 0], [2, 3, 4].
> However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.
> ```
>
> ### Note:
> * `arr` will have length in range `[1, 10]`.
> * `arr[i]` will be a permutation of `[0, 1, ..., arr.length - 1]`.

---

### Solution
* **mine**
  * **Java**
    * `Runtime: 0 ms, faster than 100.00%, Memory Usage: 36.2 MB, less than 6.59% of Java online submissions`
      ```
      // O(N)time
      // O(1)space
      public int maxChunksToSorted(int[] arr) {
          int res = 0;
          int max = 0;
          for(int i = 0; i < arr.length; i++){
              max = Math.max(max, arr[i]);
              if(i == max) res++;
          }
          return res;
      }
      ```

---


* **the most votes**  
> * `Runtime: 0 ms, faster than 100.00%, Memory Usage: 36.2 MB, less than 6.59% of Java online submissions`
>
>   The basic idea is to use max[] array to keep track of the max value until the current position, and compare it to the sorted array (indexes from 0 to arr.length - 1). If the max[i] equals the element at index i in the sorted array, then the final count++.
>   Update: As @AF8EJFE pointed out, the numbers range from 0 to arr.length - 1. So there is no need to sort the arr, we can simply use the index for comparison. Now this solution is even more straightforward with O(n) time complelxity.
>   For example,
>       original: 0, 2, 1, 4, 3, 5, 7, 6
>       max:      0, 2, 2, 4, 4, 5, 7, 7
>       sorted:   0, 1, 2, 3, 4, 5, 6, 7
>       index:    0, 1, 2, 3, 4, 5, 6, 7
>   ```
>   public int maxChunksToSorted(int[] arr) {
>       if (arr == null || arr.length == 0) return 0;
>
>       int count = 0, max = 0;
>       for (int i = 0; i < arr.length; i++) {
>           max = Math.max(max, arr[i]);
>           if (max == i) {
>               count++;
>           }
>       }
>       return count;
>   }
>   ```

---
