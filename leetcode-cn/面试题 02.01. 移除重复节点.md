# [面试题 02.01. 移除重复节点](https://leetcode-cn.com/problems/remove-duplicate-node-lcci/)


---

**leetcode-cn Daily Challenge on June 26, 2020.**

---


编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。

### 示例1:
```
 输入：[1, 2, 3, 3, 2, 1]
 输出：[1, 2, 3]
``` 

### 示例2:
```
 输入：[1, 1, 1, 1, 2]
 输出：[1, 2]
```

### 提示：
* 链表长度在[0, 20000]范围内。
* 链表元素在[0, 20000]范围内。

### 进阶：
如果不得使用临时缓冲区，该怎么解决？


---


### Solution
* **mine**
  * **Java**
    * `执行用时：6 ms, 在所有 Java 提交中击败了79.61%, 内存消耗：41.2 MB, 在所有 Java 提交中击败了100.00%的用户`
      ```
      //O(N)time O(N)space
      public ListNode removeDuplicateNodes(ListNode head) {
          HashSet<Integer> set = new HashSet<>();
          ListNode res = head;
          while(head != null){
              set.add(head.val);
              while(head != null && head.next != null && set.contains(head.next.val)){
                  ListNode next = head.next.next;
                  head.next = next;
              }
              head = head.next;
          }
          return res;
      }
      ```
  
  
---


* **leetcode-cn  O(1)space solution**
  * `执行用时：408 ms, 在所有 Java 提交中击败了8.39%的用户内存消耗：40.4 MB, 在所有 Java 提交中击败了100.00%的用户`
    ```
    //O(N^2)time O(1)space
    public ListNode removeDuplicateNodes(ListNode head) {
        ListNode ob = head;
        while (ob != null) {
            ListNode oc = ob;
            while (oc.next != null) {
                if (oc.next.val == ob.val) {
                    oc.next = oc.next.next;
                } else {
                    oc = oc.next;
                }
            }
            ob = ob.next;
        }
        return head;
    }
    ```


---
