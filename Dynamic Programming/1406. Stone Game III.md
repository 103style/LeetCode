# [1406. Stone Game III](https://leetcode.com/problems/stone-game-iii/)

---

> **Difficulty** : **Hard**
>
> **Related Topics** : **Dynamic Programming**

---

> Alice and Bob continue their games with piles of stones. There are several stones **arranged in a row**, and each stone has an associated value which is an integer given in the array `stoneValue`.
>
> Alice and Bob take turns, with **Alice** starting first. On each player's turn, that player can take **1, 2 or 3 stones** from the **first** remaining stones in the row.
>
> The score of each player is the sum of values of the stones taken. The score of each player is 0 initially.
>
> The objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken.
>
> Assume Alice and Bob **play optimally**.
>
> Return "Alice" if Alice will win, "Bob" if Bob will win or "Tie" if they end the game with the same score.
>
>
>
> ### Example 1:
> ```
> Input: values = [1,2,3,7]
> Output: "Bob"
> Explanation: Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins.
> ```
>
> ### Example 2:
> ```
> Input: values = [1,2,3,-9]
> Output: "Alice"
> Explanation: Alice must choose all the three piles at the first move to win and leave Bob with negative score.
> If Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5. The next move Alice will take the pile with value = -9 and lose.
> If Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3. The next move Alice will take the pile with value = -9 and also lose.
> Remember that both play optimally so here Alice will choose the scenario that makes her win.
> ```
>
> ### Example 3:
> ```
> Input: values = [1,2,3,6]
> Output: "Tie"
> Explanation: Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose.
> ```
>
> ### Example 4:
> ```
> Input: values = [1,2,3,-1,-2,-3,7]
> Output: "Alice"
> ```
>
> ### Example 5:
> ```
> Input: values = [-1,-2,-3]
> Output: "Tie"
> ```
>
> ### Constraints:
> * `1 <= values.length <= 50000`
> * `-1000 <= values[i] <= 1000`

---


### Solution
* **mine**
  * **Java**
    * **DFS & Memorize** `Runtime: 68 ms, faster than 28.84%, Memory Usage: 57.2 MB, less than 58.96% of Java online submissions`
      ```
      // O(N)time
      // O(N)space
      public String stoneGameIII(int[] stoneValue) {
          int n = stoneValue.length;
          int[] sum = new int[n + 1];
          for(int i = 0; i < n; i++){
              sum[i + 1] = sum[i] + stoneValue[i];
          }

          int[][] memo = new int[4][n + 1];
          for(int i = 0; i < 4 ; i++){
              Arrays.fill(memo[i], Integer.MIN_VALUE);
          }

          int dx = dfs(sum, 0, n, memo);

          if(dx > 0) return "Alice";
          else if (dx < 0) return "Bob";
          else return "Tie";
      }

      int dfs(int[] sum, int l, int r, int[][] memo) {
          if (l >= r) return 0;
          int res = Integer.MIN_VALUE;
          for (int i = 1; i <= 3 && l + i <= r; i++) {
              if (memo[i][l] != Integer.MIN_VALUE) {
                  res = Math.max(memo[i][l], res);
              } else {
                  res = Math.max(res, sum[l + i] - sum[l] - dfs(sum, l + i, r, memo));
                  memo[i][l] = res;
              }

          }
          return res;
      }
      ```


---

* **the most votes**
>  * **DP** `Runtime: 8 ms, faster than 92.11%, Memory Usage: 49.3 MB, less than 70.87% of Java online submissions`
>    ```
>    // O(N)time
>    // O(N)space
>    public String stoneGameIII(int[] stoneValue) {
>        int n = stoneValue.length;
>        int[] suffixSum = new int[n+1];
>        int[] dp = new int[n+1];
>        suffixSum[n] = 0;
>        dp[n] = 0;
>        for (int i = n - 1; i >= 0; i--)
>            suffixSum[i] = suffixSum[i + 1] + stoneValue[i];
>        for (int i = n-1; i >= 0; i--) {
>            dp[i] = stoneValue[i] + suffixSum[i+1] - dp[i+1];
>            for (int k = i+1; k < i+3 && k < n; k++) {
>                dp[i] = Math.max(dp[i], suffixSum[i]-dp[k+1]);
>            }
>        }
>        if (dp[0]*2 == suffixSum[0])
>            return "Tie";
>        else if (dp[0]*2 > suffixSum[0])
>            return "Alice";
>        else
>            return "Bob";
>    }
>    ```

---
