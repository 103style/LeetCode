# [1340. Jump Game V](https://leetcode.com/problems/jump-game-v/)
---

> Given an array of integers `arr` and an integer `d`. In one step you can jump from index `i` to index:
> * `i + x` where: `i + x < arr.length` and `0 < x <= d`.
> * `i - x` where: `i - x >= 0` and `0 < x <= d`.
>
> In addition, you can only jump from index `i` to index `j` if `arr[i] > arr[j]` and `arr[i] > arr[k]` for all indices `k` between `i` and `j` (More formally `min(i, j) < k < max(i, j)`).
>
> You can choose any index of the array and start jumping. Return the maximum number of indices you can visit.
>
> Notice that you can not jump outside of the array at any time.
>
>
>
> ### Example 1:
> ![1](https://assets.leetcode.com/uploads/2020/01/23/meta-chart.jpeg)
> ```
> Input: arr = [6,4,14,6,8,13,9,7,10,6,12], d = 2
> Output: 4
> Explanation: You can start at index 10. You can jump 10 --> 8 --> 6 --> 7 as shown.
> Note that if you start at index 6 you can only jump to index 7. You cannot jump to index 5 because 13 > 9. You cannot jump to index 4 because index 5 is between index 4 and 6 and 13 > 9.
> Similarly You cannot jump from index 3 to index 2 or index 1.
> ```
>
> ### Example 2:
> ```
> Input: arr = [3,3,3,3,3], d = 3
> Output: 1
> Explanation: You can start at any index. You always cannot jump to any index.
> ```
>
> ### Example 3:
> ```
> Input: arr = [7,6,5,4,3,2,1], d = 1
> Output: 7
> Explanation: Start at index 0. You can visit all the indicies.
> ```
>
> ### Example 4:
> ```
> Input: arr = [7,1,7,1,7,1], d = 2
> Output: 2
> ```
>
> ### Example 5:
> ```
> Input: arr = [66], d = 1
> Output: 1
> ```
>
> ### Constraints:
> * `1 <= arr.length <= 1000`
> * `1 <= arr[i] <= 10^5`
> * `1 <= d <= arr.length`

---


### Solution
* **mine**
  * **Java**
    
    * **Top-Down DP**  `got from the discuss**` 
    
      `Runtime: 11 ms, faster than 53.85%, Memory Usage: 40.3 MB, less than 21.40% of Java online submissions`
      ```
      // O(N*d)time O(N)space  
      // N is arr.length
      int[] dp;
      public int maxJumps(int[] arr, int d) {
          int len = arr.length;
          dp = new int[len];
          for (int i = 0; i < len; i++) {
              dfs(arr, i, d);
          }
          int max = 0;
          for (int v : dp) {
              max = Math.max(max, v);
          }
          return max;
      }

      public void dfs(int[] arr, int curIndex, int d) {
          if (dp[curIndex] != 0) {
              return;
          }
          dp[curIndex] = 1;
          int i = curIndex - 1;
          while (i >= 0 && curIndex - i <= d && arr[curIndex] > arr[i]) {
              dfs(arr, i, d);
              dp[curIndex] = Math.max(dp[curIndex], dp[i] + 1);
              i--;
          }
          i = curIndex + 1;
          while (i < dp.length && i - curIndex <= d && arr[curIndex] > arr[i]) {
              dfs(arr, i, d);
              dp[curIndex] = Math.max(dp[curIndex], dp[i] + 1);
              i++;
          }
      }
      ```
  
----


* **the most votes**
  * **C++** `Runtime: 92 ms, faster than 35.87%, Memory Usage: 14.8 MB, less than 69.98% of C++ online submissions`
    ```
    class Solution {
    public:
        int dp[1001] = {};
        int dfs(vector<int>& arr, int i, int d, int res = 1) {
            if (dp[i]) return dp[i];
            for (auto j = i + 1; j <= min(i + d, (int)arr.size() - 1) && arr[j] < arr[i]; ++j)
                res = max(res, 1 + dfs(arr, j, d));
            for (auto j = i - 1; j >= max(0, i - d) && arr[j] < arr[i]; --j)
                res = max(res, 1 + dfs(arr, j, d));
            return dp[i] = res;
        }
        int maxJumps(vector<int>& arr, int d, int res = 1) {
            for (auto i = 0; i < arr.size(); ++i)
                res = max(res, dfs(arr, i, d));
            return res;
        }
    };
    ```


---
