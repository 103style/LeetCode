# [763. Partition Labels](https://leetcode.com/problems/partition-labels/)

---

> A string `S` of lowercase letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.
>
> ### Example 1:
> ```
> Input: S = "ababcbacadefegdehijhklij"
> Output: [9,7,8]
> Explanation:
> The partition is "ababcbaca", "defegde", "hijhklij".
> This is a partition so that each letter appears in at most one part.
> A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits S into less parts.
> ```
> ### Note:
> * `S` will have length in range `[1, 500]`.
> * `S` will consist of lowercase letters (`'a'` to `'z'`) only.

---

### Solution
* mine `Runtime: 3 ms, faster than 87.51%, Memory Usage: 38 MB, less than 5.19%`
```
public List<Integer> partitionLabels(String S) {
    List<Integer> res = new ArrayList<>();
    int i = 0;
    int end = S.lastIndexOf(S.charAt(0));
    if (end != 0) {
        for (i = 0; i < end; i++) {
            char c = S.charAt(i);
            int t = S.lastIndexOf(c);
            if (t > end) {
                end = t;
            }
        }
    }
    i++;
    res.add(i);
    if (i < S.length()) {
        res.addAll(partitionLabels(S.substring(i)));
    }
    return res;
}
```

* most votes `Runtime: 3 ms, faster than 87.51%, Memory Usage: 36 MB, less than 96.10%`
```
class Solution {
    public List<Integer> partitionLabels(String S) {
        if(S == null || S.length() == 0){
            return null;
        }
        List<Integer> list = new ArrayList<>();
        int[] map = new int[26];  // record the last index of the each char

        for(int i = 0; i < S.length(); i++){
            map[S.charAt(i)-'a'] = i;
        }
        // record the end index of the current sub string
        int last = 0;
        int start = 0;
        for(int i = 0; i < S.length(); i++){
            last = Math.max(last, map[S.charAt(i)-'a']);
            if(last == i){
                list.add(last - start + 1);
                start = last + 1;
            }
        }
        return list;
    }
}
```
